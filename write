        else if(strcmp(tokens->items[0], "write") == 0)
        {
            /************************ ERROR CHECKING ************************/
            tokenlist *tok;
            //error flags
            int exist = 0;
            int isDir = 0;
            int isNotOpen = 0;
            int error = 0; //if there are no errors, continue with write
            unsigned int fileCluster;
            unsigned int filesize;
            unsigned int fileOffset;
            unsigned int offsetPos;
            //check for correct number of args
            if(tokens->size != 4)
            {  
                printf("ERROR: wrong number of arguments\n");
                continue;
            }

            //check to see if file exist
            for(int i = 0; i < dirTrack; i++)
            {
                tok = get_tokens(dir[i].DIRName);
                if((strcmp(tokens->items[1], tok->items[0]) == 0)
                    && (dir[i].DIRAttr == 0x20))
                {
                    exist = 1;
                    filesize = dir[i].DIRSize;
                    fileCluster = dir[i].lowCluster;
                    break;
                }
                else if((strcmp(tokens->items[1], tok->items[0]) == 0)
                    && (dir[i].DIRAttr == 0x10))
                {
                    printf("ERROR: %s is a Directory\n", tokens->items[1]);
                    error = 1;
                    isDir = 1;
                    break;
                }
            }

            if(exist)
            {
                //check open table to see if file is open for writing
                for(int x = 0; x < 100; x++)
                {
                    //check if file is in open table
                    if(strcmp(tokens->items[1], op[x].filename) == 0)
                    {
                        /*printf("Filename: %s\n", op[x].filename);
                        printf("Mode: %s\n", op[x].mode);
                        printf("Start Cluster: %d\n", op[x].startCluster);
                        printf("offset_position: %d\n", op[x].offset_position);*/
                        
                        offsetPos = op[x].offset_position;
                        isNotOpen = 0;
                        break;
                    }
                    isNotOpen = 1; //flag will remain 1 unless file is found
                }
            }
            //if file does not exist
            if(!exist && !isDir)
            {
                printf("ERROR: %s does not exist\n", tokens->items[1]);
                error = 1;
                continue;
            }

            if(isNotOpen)
            {
                printf("ERROR: %s is not open for writing\n", tokens->items[1]);
                error = 1;
                continue;
            }
            /************************ ERROR CHECKING ************************/

            //if we don't have any errors, continue to write
            if(!error)
            {   
                unsigned int bytes = atoi(tokens->items[2]);
                //offset in the data region 
                unsigned int filePosOffset = findCluster(fileCluster) + offsetPos;
                //strip quotes from filename
                char string[strlen(tokens->items[3])];
                strcpy(string, tokens->items[3]);
                char *str = string;
                str++;
                str[strlen(str) - 1] = 0;

                //if offset + size is larger than file, need to extend file length 
                unsigned int offset = offsetPos + bytes;
                unsigned int newBytes = Bytes(bytes, tokens->items[3]);
                printf("New Bytes%d\n", newBytes);
                if(offset > filesize)
                {
                    //printf("offset + SIZE is larger than filesize\n");
                    myWriteFunc(fd, offsetPos, newBytes, fileCluster, filesize, 1, str);
                }
                else
                {
                    //have the fileExtend flag set to 0
                    myWriteFunc(fd, offsetPos, newBytes, fileCluster, filesize, 0, str);
                }

            }
            else //prompt user for another command
                continue;
        }
        
 void myWriteFunc(int fd, int offset, int bytesToWrite, int fileCluster, 
                int filesize, int fileExtend, char* string)
{
    findFatSequence(fd, fileCluster);
    unsigned int filePosOffset = findCluster(fileCluster) + offset;
    unsigned int buf;

    //need to extend the length of the file
    if(fileExtend)
    {
        printf("Filename: %s\n", string);
        printf("Filesize: %d\n", filesize);
        int extraClusters;
        int currentClusters = (int)(filesize / 512);
        int finalCluster = (int)(offset + bytesToWrite) / 512;

        printf("Current Clusters: %d\n", currentClusters);
        printf("Final Cluster: %d\n", finalCluster);

        if((filesize % 512) > 0)
            currentClusters++;

        if((offset + bytesToWrite) % 512 > 0)
            finalCluster++;

        extraClusters = finalCluster - currentClusters;
        printf("Extra Clusters needed: %d\n", extraClusters);
        int current = fileCluster;
        int track = 0;
        int trackFAT = 0;
        int clusterNum;

        //find empty cluster in FAT
        for(int i = 0; i < extraClusters; i++)
        {
            while(1)
            {
                //printf("TEST\n");
                //seek to start of FAT
                lseek(fd, 16384+track, SEEK_SET);
                //read 4 bytes
                read(fd, &buf, 4);
                if(buf == 0)
                {   
                    clusterNum = track/4;
                    printf("Cluster num: %X\n", clusterNum);

                    trackFAT++;
                    break;
                }
                track += 4;
            }
            
            //adds the new cluster and makes the empty cluster the new end
            lseek(fd, 16384 + fat[fatTrack]*4, SEEK_SET);
            buf = (int)clusterNum;
            write(fd, &buf, 4);
            buf = (int)0x0FFFFFF8;
            lseek(fd, 16384 + clusterNum*4, SEEK_SET);
            write(fd, &buf, 4);
            fatTrack++;
            fat[fatTrack] = clusterNum;
        }

        int totalBytes = bytesToWrite;
        int bytesRemaining = findCluster(fileCluster+1) - filePosOffset;
        //go back to the start of the file
        lseek(fd, filePosOffset, SEEK_SET);

        for(int i = 0; i <= extraClusters; i++)
        {   
            /*  char string[strlen(tokens->items[3])];
                strcpy(string, tokens->items[3]);
                char *str = string;
                str++;
                str[strlen(str) - 1] = 0; */

            unsigned char *buffer = malloc(sizeof(unsigned char)*bytesRemaining);
            string = strncpy(&buffer, string, bytesRemaining);
            printf("%s\n", buffer);


            write(fd, &buffer, bytesRemaining);
            totalBytes -= bytesRemaining;
            //
            lseek(fd, findCluster(fat[fatTrack - trackFAT + 1]), SEEK_SET);
            if(totalBytes > 512)
                bytesRemaining = 512;
            else
                bytesRemaining = totalBytes;
            
            printf("Bytes remaining: %d\n", bytesRemaining);
        }

        printf("Total Bytes:%d\n", totalBytes);
    }

    else //no clusters need to be allocated
    {

    }
